---
title: "Parameterizing Soybean-BioCro"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Parameterizing Soybean-BioCro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
link-citations: yes
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7.5,
  fig.height = 5,
  fig.align = "center"
)
```

# Overview

This article shows how to create an objective function that can be used to
parameterize BioCro's soybean model
[@matthews_soybean_biocro_2021; @lochocki_biocro_2022].

Since the original publication of Soybean-BioCro, the BioCro module library has
undergone several changes, and the model has been re-parameterized several
times. These parameterizations did not use `BioCroValidation`, since they were
performed before `BioCroValidation` was created.

However, `BioCroValidation` is able to re-create the objective functions that
were used for these parameterizations. Here, we re-create the objective function
that was used for the parameterization included in version `3.2.0` of the BioCro
R package.

In the commands below, we will use functions from several libraries, so we will
load them now:

```{r libraries}
# Load required libraries
library(BioCroValidation)
library(BioCro)
library(lattice)
```

# Building the Objective Function

In this section, we will use the `objective_function` function from
`BioCroValidation` package to create an objective function that can be used to
parameterize Soybean-BioCro. For more details about this, please see the help
page for `objective_function` by typing `?objective_function` from an R
terminal.

## The Base Model Definition

We first need a base model definition that includes the necessary modules,
initial values, parameters, and differential equation solver specifications. For
this example, we will simply use Soybean-BioCro as the base model, with just one
small change: we will use an Euler solver rather than the default solver, which
will help make the optimization run faster. For reasonable sets of parameter
values, the Euler solver does not seem to cause any substantial errors when
running Soybean-BioCro.

```{r base_model_definition}
# Specify the base model definition
base_model_definition            <- soybean
base_model_definition$ode_solver <- default_ode_solvers[['homemade_euler']]
```

## The Observed Data

The observed data needed to parameterize Soybean-BioCro is included in the
`BioCroValidation` package as the `soyface_biomass` data set, which consists of
two years (2002 and 2005) of biomass data and associated standard deviations,
included in four separate tables. However, each table requires some
pre-processing to get it ready.

One issue is that the data set specifies the doy of year (DOY) for each harvest,
but we need to specify the time using BioCro's convention (the number of hours
since the start of the year). This can be addressed by defining a helper
function that adds a new `time` column following BioCro's convention:

```{r convert_time}
# Define a helping function for adding a `time` column
convert_time <- function(data_table) {
  within(data_table, {
    # Define new `time` column
    time = (DOY - 1) * 24.0
  })
}
```

Another issue is that the data set includes pod and seed values, but
Soybean-BioCro calculates shell and seed masses, where the shell and seed
together comprise the pod. This can also be addressed with helper functions,
which will be different for biomass values and standard deviations:

```{r get_shell}
# Define a helping function for calculating shell biomass
add_shell_biomass <- function(data_table) {
  within(data_table, {
    # The shell is all parts of the pod other than the seed
    Shell_Mg_per_ha = Rep_Mg_per_ha - Seed_Mg_per_ha
  })
}

# Define a helping function for calculating shell biomass standard deviation
add_shell_stdev <- function(data_table) {
  within(data_table, {
    # Add uncertainties in quadrature, a simple approach to error propagation
    Shell_Mg_per_ha = sqrt(Rep_Mg_per_ha^2 + Seed_Mg_per_ha^2)
  })
}
```

Although the observations do not include root biomass, it is nevertheless
important to constrain the predicted root mass to reasonable values. To do this,
it is assumed that the maximum root mass is seventeen percent of the maximum
aboveground biomass, and that it is achieved at the same time as maximum
above-ground biomass, based on observations reported in @ordonez_root_2020. In
the observed data, the sum of stem and leaf mass is largest at the fifth time
point in both years. So, root mass is estimated at this single time point and
added to the observed values.

In previous parameterizations, a standard deviation for the root mass was not
explicitly estimated; instead, the standard-deviation-based weight factor was
implicitly set to 1. Because the `'logarithm'` method was used, a weight factor
of 1 implies a standard deviation of \(1 / e - 10^{-5} \approx 0.3678694\). See
the documentation page (`?objective_function`) for more information about this
weighting method.

The root mass and its standard deviation can be added with another set of helper
functions. Note that any observations set to `NA` will be ignored when
calculating the error metric.

```{r get_root}
# Define a helping function for adding the root mass
add_root_biomass <- function(data_table) {
  # Initialize all values to NA
  data_table$Root_Mg_per_ha <- NA

  # Estimate a mass at one time point
  row_to_use <- 5

  col_to_add <- c(
    'Leaf_Mg_per_ha',
    'Stem_Mg_per_ha',
    'Rep_Mg_per_ha'
  )

  data_table[row_to_use, 'Root_Mg_per_ha'] <-
    0.17 * sum(data_table[row_to_use, col_to_add])

  data_table
}

# Define a helping function for adding the root standard deviation
add_root_stdev <- function(data_table) {
  # We can set a value for each time point; any time points where the root mass
  # is NA will be ignored
  data_table$Root_Mg_per_ha <- 1 / exp(1) - 1e-5

  data_table
}
```

Finally, the data set includes some values that are not needed for the
parameterization. This includes the leaf litter accumulated between each
harvest, as well as the `DOY` and `Rep_Mg_per_ha` columns that have been
superseded by other columns defined above. These can be removed with a final
helper function:

```{r remove_columns}
# Define a helping function for removing unneeded columns
remove_extra_columns <- function(data_table) {
  within(data_table, {
    # Remove columns by setting them to NULL
    DOY              = NULL
    Rep_Mg_per_ha    = NULL
    Litter_Mg_per_ha = NULL
  })
}
```

Now we can apply these to each table in the set:

```{r process_tables}
# Process the data sets (biomass and stdev from 2002 and 2005)
ambient_2002_biomass <-
  remove_extra_columns(add_root_biomass(add_shell_biomass(convert_time(
    soyface_biomass[['ambient_2002']]
  ))))

ambient_2005_biomass <-
  remove_extra_columns(add_root_biomass(add_shell_biomass(convert_time(
    soyface_biomass[['ambient_2005']]
  ))))

ambient_2002_stdev <-
  remove_extra_columns(add_root_stdev(add_shell_stdev(convert_time(
    soyface_biomass[['ambient_2002_std']]
  ))))

ambient_2005_stdev <-
  remove_extra_columns(add_root_stdev(add_shell_stdev(convert_time(
    soyface_biomass[['ambient_2005_std']]
  ))))
```

## The Data-Driver Pairs

The `BioCro` R package includes weather data for the years in the
`soyface_biomass` data set. So now we are ready to define the data-driver pairs,
which includes the weather, the observed biomass, the standard deviation of the
observed biomass, and the weight to assign to each year:

```{r data_driver_pairs}
# Define the data-driver pairs
data_driver_pairs <- list(
  ambient_2002 = list(
    data       = ambient_2002_biomass,
    data_stdev = ambient_2002_stdev,
    drivers    = BioCro::soybean_weather[['2002']],
    weight     = 1
  ),
  ambient_2005 = list(
    data       = ambient_2005_biomass,
    data_stdev = ambient_2005_stdev,
    drivers    = BioCro::soybean_weather[['2005']],
    weight     = 1
  )
)
```

Here we have chosen equal weights for the two years.

## The Post-Processing Function

The observed data includes values of the total litter, which is comprised of
both leaf and stem litter. However, the model does not calculate this quntity;
instead, it returns separate values of leaf and stem litter. To address this
issue, we can provide a "post-processing function." This is an (optional)
function that is applied to each simulation result and can be used to add new
columns. Here we define such a function, which adds a new column for the total
litter:

```{r post_process_function}
# Define the post-processing function
post_process_function <- function(sim_res) {
  # Calculate the total litter as the sum of leaf and stem litter
  within(sim_res, {TotalLitter = LeafLitter + StemLitter})
}
```

## The Data Definitions

The data sets above have columns whose names do not match the corresponding
model outputs. For example, the `Leaf_Mg_per_ha` column of the observed data
must be compared to the `Leaf` column of the model output, since both represent
the leaf mass per unit ground area. To handle this mismatch, we can provide a
set of "data definitions" that specify which columns should be compared:

```{r data_definitions}
# Define the data definition list, where the element names are columns in the
# observed data tables, and the element values are the corresponding column
# names in the model outputs
data_definitions <- list(
# Observed               Simulated
  CumLitter_Mg_per_ha = 'TotalLitter',
  Leaf_Mg_per_ha      = 'Leaf',
  Root_Mg_per_ha      = 'Root',
  Seed_Mg_per_ha      = 'Grain',
  Shell_Mg_per_ha     = 'Shell',
  Stem_Mg_per_ha      = 'Stem'
)
```

## The Arguments to Vary

Here we wish to vary several parameters related to carbon partitioning for
growth, senescence, maintenance respiration, and growth respiration:

- For each growing tissue, there are two parameters (\(\alpha\) and \(\beta\))
  that influence the parbon partitioning coefficients. Here we will vary these
  for the leaf, stem, and shell (6 parameters in total).

- For each senescing tissue, there are three parameters (\(\alpha_{sen}\),
  \(\beta_{sen}\), and `rate`) that influence when senescence begins and
  the overall rate of scenescence. Here we will vary these for the leaf and stem
  (6 parameters in total).

- For each growing tissue, there is one parameter (`grc`) that influences the
  rate of carbon use for growth respiration. Here we will vary these for the
  stem and root (2 parameters in total).

- For each tissue, there is one parameter (`mrc`) that influences the rate of
  carbon use for maintenance respiration. Here we will vary these for the leaf,
  stem, and root (3 parameters in total).

Together, this is 17 arguments to vary. Typically, an optimization problem
requires more time for each free parameter involved, so it is helpful to vary
the smallest possible set. One way to reduce the number of free parameters is to
treat some as being "dependent." In other words, to calculate the values of some
parameters from the values of others, so that only some of them are truly free
or "independent." Here we will do this by fixing the value of `mrc_stem` to the
value of `mrc_leaf`. Thus, we can think of this is a single maintenance
respiration coefficient for the entire shoot; this reduces the number of
independent parameters by one (to 16).

The independent arguments must be specified as a list of named numeric elements,
where the name is the argument name and the value is an initial guess for that
argument. Here we will use the default Soybean-BioCro values as our initial
guesses:

```{r independent_args}
# Define a list of independent arguments and their initial values
independent_arg_names <- c(
  # Partitioning for leaf, stem, and shell
  'alphaLeaf',
  'betaLeaf',
  'alphaStem',
  'betaStem',
  'alphaShell',
  'betaShell',

  # Senescence for leaf and stem
  'alphaSeneLeaf',
  'betaSeneLeaf',
  'rateSeneLeaf',
  'alphaSeneStem',
  'betaSeneStem',
  'rateSeneStem',

  # Growth respiration for stem and root
  'grc_stem',
  'grc_root',

  # Maintenance respiration for leaf and root
  'mrc_leaf',
  'mrc_root'
)

independent_args <- soybean$parameters[independent_arg_names]
```

The dependent arguments must be specified as a function that takes a list of
independent arguments as its input, and returns a list of dependent arguments as
its output:

```{r dependent_arg_function}
# Define a function that sets `mrc_stem` to the value of `mrc_leaf`
dependent_arg_function <- function(ind_args) {
  list(mrc_stem = ind_args[['mrc_leaf']])
}
```

## The Quantity Weights

When determining the error metric value, we wish to assign different weights to
each type of observed value. This can be handled via the `quantity_weights`,
which must be a list of named numeric elements, where the name of each element
is an output from the simulation, and its value is the weight.

```{r quantity_weights}
# Specify the quantity weights; there is no systematic way to determine these,
# but the following weights have worked well in the past for Soybean-BioCro
quantity_weights <- list(
  Grain       = 1.0,
  Leaf        = 1.0,
  Root        = 0.1,
  Shell       = 0.5,
  Stem        = 1.0,
  TotalLitter = 0.1
)
```

## The Extra Penalty Function

Sometimes an optimizer may choose parameter values that produce close agreement
with the observed data but are nevertheless unreasonable from a biological
perspective.

To prevent these unreasonable parameters from being chosen, "extra penalties"
can be added to the error metric. These penalties can be specified using an
`extra_penalty_function`, which must take the result from a BioCro simulation
as its input and return a numeric error penalty value, which generally should be
zero (when no issues are found) or a large positive number (if an issue has been
found).

For Soybean-BioCro parameterization, three common issues are that:

1. Carbon is never partitioned to one or more key tissues.

2. Carbon partitioning to the stem and leaf starts at different times.

3. Carbon partitioning to the leaves begins too early or too late.

The function below will return a large value when any of these situations
occurs, and will otherwise return a value of zero.

```{r extra_penalty_function}
# Define an extra penalty function
extra_penalty_function <- function(sim_res) {
  # Set the penalty value
  PENALTY <- 9999

  # Get the first times when each partitioning coefficient becomes non-zero
  k_thresh <- 0.01 # Threshold k value to decide when growth has started
  hpd      <- 24.0 # Hours per day

  time <- sim_res[['time']]

  time_grain <- time[sim_res[['kGrain']] > k_thresh][1]
  time_leaf  <- time[sim_res[['kLeaf']]  > k_thresh][1]
  time_shell <- time[sim_res[['kShell']] > k_thresh][1]
  time_stem  <- time[sim_res[['kStem']]  > k_thresh][1]

  # Return a penalty if necessary
  if (is.na(time_grain) | is.na(time_leaf) | is.na(time_shell) | is.na(time_stem)) {
    # One or more tissues is not growing
    return(PENALTY)
  } else if (abs(time_leaf - time_stem) > 5 * hpd) {
    # The starts of leaf and stem growth are more than 5 days apart
    return(PENALTY)
  } else if (time_leaf - time[1] > 20 * hpd | time_leaf - time[1] < 10 * hpd) {
    # The start of leaf growth is too late (more than 20 days after sowing) or
    # too early (fewer than 10 days after sowing)
    return(PENALTY)
  } else {
    # No problems were detected
    return(0.0)
  }
}
```

## The Objective Function

Now we are just about ready to build the objective function. There are a few
more details to discuss:

- Soybean-BioCro has always used the `'mean_max'` method for determining
  normalization factors; see Equations 14-16 of @matthews_soybean_biocro_2021
  for more details.

- Soybean-BioCro has always used the `'logarithm'` method for determining
  weights from standard deviations; see Equation 17 of
  @matthews_soybean_biocro_2021 for more details.

- Soybean-BioCro has not used any regularization.

With this, it is possible to build the function. Note that some useful
information is printed out when the function is created, such as the full list
of observed values and their corresponding weights.

```{r objective_function}
# Create the objective function
obj_fun <- objective_function(
  base_model_definition,
  data_driver_pairs,
  independent_args,
  quantity_weights,
  data_definitions       = data_definitions,
  normalization_method   = 'mean_max',
  stdev_weight_method    = 'logarithm',
  regularization_method  = 'none',
  dependent_arg_function = dependent_arg_function,
  post_process_function  = post_process_function,
  extra_penalty_function = extra_penalty_function
)
```

# Commands From This Document

```{r, eval = FALSE}
###
### Preliminaries
###

<<libraries>>

###
### Define helping functions
###

<<convert_time>>

<<get_shell>>

<<get_root>>

<<remove_columns>>

###
### Prepare inputs for `objective_function` and call it
###

<<base_model_definition>>

<<process_tables>>

<<data_driver_pairs>>

<<post_process_function>>

<<data_definitions>>

<<independent_args>>

<<dependent_arg_function>>

<<quantity_weights>>

<<extra_penalty_function>>

<<objective_function>>

```

# References
